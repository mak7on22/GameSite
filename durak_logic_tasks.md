# Задание для Codex: реализация логики «Дурак онлайн» (1 × 1, игрок vs ИИ)

> Цель — довести прототип до полностью играбельного состояния в одиночном режиме. Все пункты выполнять последовательно; переход к следующему этапу допускается только после прохождения юнит‑тестов предыдущего.

## Этап 1. Базовые структуры и инициализация

1. Создать типы/классы `Card`, `Player`, `GameState` (см. описание ниже).
2. Реализовать генератор колоды нужного размера (24/36/52) и алгоритм перемешивания (Fisher‑Yates).
3. Добавить функцию `dealInitial(state)`: раздать по 6 карт, определить козырь и первого атакующего (минимальный козырь).
4. Покрыть пункт 1‑3 юнит‑тестами (Jest): уникальность карт, корректный выбор козыря, правильный лидер.

## Этап 2. Атака и защита

5. Имплементировать `attack(cardId)` — проверка, что ходит текущий атакующий и карта принадлежит ему.
6. Добавить валидацию подкидывания: ранг должен совпадать с любой картой на столе; максимум 6 карт на стол.
7. Реализовать `defend(attackIndex, cardId)` — правила перекрытия (старшая масть|козырь).
8. Обновить UI: при недопустимом ходе показывать toast‑ошибку, карта возвращается в руку.
9. Покрыть тестами: невозможно подкинуть лишнюю карту, нельзя отбиться недопустимой.

## Этап 3. Завершение раунда

10. Кнопка **«Бито»** активна, когда все карты перекрыты; по клику пары уходят в отбой, `phase = "refill"`.
11. Кнопка **«Забрать»** активна, если есть непокрытая карта; по клику все карты стола переходят в руку защитника, `phase = "refill"`.
12. Написать `refillHands(state)`: добор до 6 карт, начиная с атакующего, козырь уходит в руку последним.
13. Добавить отображение счётчика колоды и анимацию добора.
14. Тесты: после refill у обоих ≤ 6 карт; колода сокращается верно.

## Этап 4. Смена ролей и новый раунд

15. Определить нового атакующего:
    - если «Бито» — следующий по часовой стрелке;
    - если «Забрал» — забравший становится атакующим.
16. Сбросить `table` и начать этап 2 заново.
17. Тесты: правильное распределение ролей в обоих сценариях.

## Этап 5. Конец игры

18. Условие победы: колода пуста **и** у одного из игроков нет карт.
19. Объявить победителя («дурак» — тот, у кого остались карты). Заблокировать UI.
20. Тест: искусственно довести state до финала, проверить объявление результата.

## Этап 6. Искусственный интеллект (минимум «Medium»)

21. Написать `aiMove(state)` — вызывает `attack` или `defend` по необходимости.
22. Алгоритм:
    - **Атака** — минимальная не‑козырная карта; если рангов ≥ 2, подкидывает вторую.
    - **Защита** — минимальная подходящая карта; козырь только если вариантов нет.
23. Встроить таймер 600–900 мс для «обдумывания».
24. Тест: смоделировать 1000 партий, убедиться, что ИИ не нарушает правил.

## Этап 7. Усиленный ИИ (по желанию)

25. Вести счёт оставшихся козырей и рангов, выбирать ход с минимальным «стоимостным» ущербом (эвристика). Обсудить с тим‑лидом.

## Этап 8. Анти‑чит в one‑page режиме

26. Любое действие игрока проходит через функцию‑валидатор на «серверной» стороне (в ASP.NET — контроллер или SignalR‑hub). Клиент получает результат, а не исполняет логику локально.
27. В p2p‑режиме (будущее) предусмотрено хэширование колоды + подпись хода.

---

### Описание структур

```ts
interface Card {
  id: string;          // "8_of_hearts"
  rank: number;        // 6–14
  suit: "clubs" | "diamonds" | "hearts" | "spades";
}
interface Player { hand: Card[]; role: "human" | "ai"; }
interface TablePair { attack: Card; defense?: Card; }
interface GameState {
  deck: Card[];
  trump: string;        // suit
  attacker: "human" | "ai";
  defender: "human" | "ai";
  table: TablePair[];
  phase: "attack" | "defense" | "resolution" | "refill" | "finished";
}
```

---

**Сроки:** этапы 1–6 обязательны, выполнить за 10 рабочих дней. Этап 7 — бонус; этап 8 — закладка под будущее без полной реализации.

